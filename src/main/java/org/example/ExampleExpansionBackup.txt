import me.clip.placeholderapi.expansion.PlaceholderExpansion;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import org.bukkit.block.Block;
import org.bukkit.block.data.BlockData;
import org.bukkit.entity.Entity;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitTask;
import org.bukkit.util.Vector;
import org.bukkit.Color;
import org.bukkit.Particle.DustOptions;
import org.bukkit.potion.PotionEffect;
import org.bukkit.potion.PotionEffectType;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * %Archistructure_laserPointer_MAXRADIUS,RADIUS,TIME,DISPLACEMENT,dx,SIZE,TARGET,VIEWDISTANCE,PARTICLE,(optional:color)%
 *
 * Fires a “laser” from the player’s eye in direction faced.
 * - MAXRADIUS: how far to trace (in blocks)
 * - RADIUS: cylinder radius around each trace step for entity hits
 * - TIME: total duration (ticks) to repeat the effect
 * - DISPLACEMENT: interval (ticks) between repeats
 * - dx: step size (blocks) along the ray
 * - SIZE: particle size/extra parameter
 * - TARGET: either "@a" or a single-player UUID
 * - VIEWDISTANCE: "force" or "normal" (≤64 blocks)
 * - PARTICLE: any Particle enum
 * - color (opt): hex "#RRGGBB" for REDSTONE dust
 *
 * Returns:
 * - the UUID of the first entity hit
 * - "block<world>,<x>,<y>,<z>" if it hits a solid block
 * - "n/a" if nothing was hit within MAXRADIUS
 */
public class LaserPointerExpansion extends PlaceholderExpansion {

    private final Plugin plugin;

    public LaserPointerExpansion(Plugin plugin) {
        this.plugin = plugin;
    }

    @Override public boolean    persist()      { return true; }
    @Override public String     getIdentifier(){ return "Archistructure"; }
    @Override public String     getAuthor()    { return "YOUR_NAME"; }
    @Override public String     getVersion()   { return "1.0"; }

    @Override
    public String onPlaceholderRequest(Player p, String identifier) {
        if (!identifier.startsWith("laserPointer_")) {
            return null;
        }

        // parse args
        String[] parts = identifier.substring("laserPointer_".length()).split(",");
        if (parts.length < 9) return "";

        double maxRadius;
        double cylinderRadius;
        int    totalTime;
        int    displacement;
        double dx;
        double size;
        String targetSel;
        String viewDistMode;
        Particle particle;
        DustOptions dustOpts = null;

        try {
            maxRadius      = Double .parseDouble(parts[0]);
            cylinderRadius = Double .parseDouble(parts[1]);
            totalTime      = Integer.parseInt(parts[2]);
            displacement   = Integer.parseInt(parts[3]);
            dx             = Double .parseDouble(parts[4]);
            size           = Double .parseDouble(parts[5]);
            targetSel      = parts[6];
            viewDistMode   = parts[7];
            particle       = Particle.valueOf(parts[8].toUpperCase());
            if (particle == Particle.REDSTONE && parts.length >= 10) {
                java.awt.Color awt = java.awt.Color.decode(parts[9]);
                dustOpts = new DustOptions(
                    Color.fromBGR(awt.getBlue(), awt.getGreen(), awt.getRed()),
                    (float)size
                );
            }
        } catch (Exception ex) {
            return "";
        }

        Location eye = p.getEyeLocation();
        Vector    dir = eye.getDirection().normalize();

        // determine viewers
        List<Player> viewers = new ArrayList<>();
        if (targetSel.equalsIgnoreCase("@a")) {
            viewers.addAll(p.getWorld().getPlayers());
        } else {
            try {
                Player t = Bukkit.getPlayer(UUID.fromString(targetSel));
                if (t != null) viewers.add(t);
            } catch (IllegalArgumentException ignored) {}
        }
        if (viewers.isEmpty()) return "n/a";

        // initial single‐cast to get hit result
        Entity   hitEntity   = null;
        Location hitBlockLoc = null;

        cast:
        for (double dist = 0; dist <= maxRadius; dist += dx) {
            Location loc = eye.clone().add(dir.clone().multiply(dist));
            Block    b   = loc.getBlock();
            Material m   = b.getType();

            // transparent check
            if (!(m.isAir()
               || m == Material.WATER || m == Material.LAVA
               || m == Material.BARRIER
               || m == Material.GLASS
               || m == Material.GLASS_PANE
               || m.toString().endsWith("_GLASS"))) {

                hitBlockLoc = loc;
                break cast;
            }

            // entity check
            for (Entity e : loc.getWorld().getNearbyEntities(
                    loc, cylinderRadius, cylinderRadius, cylinderRadius)) {
                if (e instanceof LivingEntity) {
                    hitEntity = e;
                    break cast;
                }
            }
        }

        // schedule repeating visual effect
        BukkitTask task = Bukkit.getScheduler().runTaskTimer(plugin, () -> {
            for (double dist = 0; dist <= maxRadius; dist += dx) {
                Location loc = eye.clone().add(dir.clone().multiply(dist));
                Block    b   = loc.getBlock();
                Material m   = b.getType();

                if (!(m.isAir()
                   || m == Material.WATER || m == Material.LAVA
                   || m == Material.BARRIER
                   || m == Material.GLASS
                   || m == Material.GLASS_PANE
                   || m.toString().endsWith("_GLASS"))) {
                    break;
                }
                for (Entity e : loc.getWorld().getNearbyEntities(
                        loc, cylinderRadius, cylinderRadius, cylinderRadius)) {
                    if (e instanceof LivingEntity) {
                        ((LivingEntity)e).addPotionEffect(
                            new PotionEffect(PotionEffectType.GLOWING, totalTime, 0)
                        );
                        break;
                    }
                }
                // spawn particles
                for (Player viewer : viewers) {
                    double dsq = viewer.getLocation().distanceSquared(loc);
                    if (viewDistMode.equalsIgnoreCase("force") || dsq <= 64*64) {
                        if (particle == Particle.REDSTONE && dustOpts != null) {
                            viewer.spawnParticle(particle, loc, 1, 0, 0, 0, 0, dustOpts);
                        } else {
                            viewer.spawnParticle(particle, loc, 1, 0, 0, 0, size);
                        }
                    }
                }
            }
        }, 0L, displacement);

        // auto-cancel after totalTime
        Bukkit.getScheduler().runTaskLater(plugin, task::cancel, totalTime);

        // return appropriate hit info
        if (hitEntity != null) {
            return hitEntity.getUniqueId().toString();
        } else if (hitBlockLoc != null) {
            return String.format("block%s,%d,%d,%d",
                hitBlockLoc.getWorld().getName(),
                hitBlockLoc.getBlockX(),
                hitBlockLoc.getBlockY(),
                hitBlockLoc.getBlockZ()
            );
        } else {
            return "n/a";
        }
    }
}